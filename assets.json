{
    "matcap": {
        "Anomaly (4N0M4LY)": "Anomaly (4N0M4LY).png",
        "Aspect (45P3C7)": "Aspect (45P3C7).png",
        "Blade (BL4D3)": "Blade (BL4D3).png",
        "Boggle (B066L3)": "Boggle (B066L3).png",
        "DFDFCA_4D2D07_6B5224_857145-256px": "DFDFCA_4D2D07_6B5224_857145-256px.png",
        "DFDFD6_58544E_81766A_989288-256px": "DFDFD6_58544E_81766A_989288-256px.png",
        "Essence (3553NC3)": "Essence (3553NC3).png",
        "Fluke (FLUK3)": "Fluke (FLUK3).png",
        "Ghoul (6H0UL)": "Ghoul (6H0UL).png",
        "Grace (6R4C3)": "Grace (6R4C3).png",
        "Knot (KN07)": "Knot (KN07).png",
        "Myth (MY7H)": "Myth (MY7H).png",
        "Nightmare (N16H7M4R3)": "Nightmare (N16H7M4R3).png",
        "Oddity (0DD17Y)": "Oddity (0DD17Y).png",
        "Quake (QU4K3)": "Quake (QU4K3).png",
        "Riddle (R1DDL3)": "Riddle (R1DDL3).png",
        "Rogue (R06U3)": "Rogue (R06U3).png",
        "Sage (5463)": "Sage (5463).png",
        "Serenity (53R3N17Y)": "Serenity (53R3N17Y).png",
        "Serpent (53RP3N7)": "Serpent (53RP3N7).png",
        "Trixy (7R1XY)": "Trixy (7R1XY).png",
        "Vacuum (V4CUUM)": "Vacuum (V4CUUM).png"
    },
    "samples": {
        "ClearcoatTest.glb": "ClearcoatTest.glb",
        "Coke Fridge.glb": "Coke Fridge.glb",
        "DamagedHelmet.gltf": "DamagedHelmet.gltf",
        "IridescentDishWithOlives.glb": "IridescentDishWithOlives.glb",
        "Nurbs.fbx": "Nurbs.fbx",
        "Parrot.glb": "Parrot.glb",
        "Soldier.glb": "Soldier.glb",
        "Teapot.glb": "Teapot.glb"
    },
    "hdr": {
        "atelier": "atelier.hdr",
        "autumn": "autumn.hdr",
        "clouds": "clouds.hdr",
        "flick": "flick.hdr",
        "gdansk": "gdansk.hdr",
        "lenong": "lenong.hdr",
        "panorama": "panorama.hdr",
        "patio": "patio.hdr",
        "quarry": "quarry.hdr",
        "tomoco": "tomoco.hdr"
    },
    "texts": {
        "about_md": "# preview_3d\nFeature-rich meshes preview for Windows, Macos and Linux.\n## Authors\n    - Code: __@sanyabeast__\n    - Icon: __@nataleesha__\n## Credids\n    - Mr. Doob & THREE.js team\n    - Electron team\n    - Tweakpane team\n__Kyiv, Ukraine, 2023__",
        "dither_alphatest_glsl": "#ifdef USE_ALPHATEST\r\n\tfloat ad_orig_alpha = diffuseColor.a;\r\n\tfloat alpha_dithered = 1.;\r\n\tfloat ad_x_fract = pow( fract(gl_FragCoord.x / round(((1.-ad_orig_alpha) + 1.) * 1.)) , 1. );\r\n\tfloat ad_y_fract = pow( fract(gl_FragCoord.y / round(((1.-ad_orig_alpha) + 1.) * 1.)) , 1. );\r\n\r\n\talpha_dithered = pow(\r\n\t\t(ad_x_fract + ad_y_fract) * pow(ad_orig_alpha, mix(0.2, 1.5, ad_orig_alpha)) + pow(ad_orig_alpha, 1.5),\r\n\t\t2.\r\n\t);\r\n\t\r\n\tif ( alpha_dithered < alphaTest ) discard;\r\n#endif",
        "info_md": "\n# keycodes\n## frame scene\n- [f] [space] [numpad .] [\\]\n\n## open file\n- [enter]\n\n## reload scene\n- [r]\n\n## collapse gui\n- [escape]\n",
        "pcss_glsl": "#define LIGHT_WORLD_SIZE 0.005\r\n#define LIGHT_FRUSTUM_WIDTH 3.75\r\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\r\n#define NEAR_PLANE 9.5\r\n\r\n#define NUM_SAMPLES 17\r\n#define NUM_RINGS 11\r\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\r\n\r\nvec2 poissonDisk[NUM_SAMPLES];\r\n\r\nvoid initPoissonSamples(const in vec2 randomSeed) {\r\n    float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\r\n    float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\r\n\r\n\t\t\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\r\n    float angle = rand(randomSeed) * PI2;\r\n    float radius = INV_NUM_SAMPLES;\r\n    float radiusStep = radius;\r\n\r\n    for(int i = 0; i < NUM_SAMPLES; i++) {\r\n        poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\r\n        radius += radiusStep;\r\n        angle += ANGLE_STEP;\r\n    }\r\n}\r\n\r\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\r\n    return (zReceiver - zBlocker) / zBlocker;\r\n}\r\n\r\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\r\n\t\t\t\t\t// This uses similar triangles to compute what\r\n\t\t\t\t\t// area of the shadow map we should search\r\n    float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\r\n    float blockerDepthSum = 0.0;\r\n    int numBlockers = 0;\r\n\r\n    for(int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\r\n        float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\r\n        if(shadowMapDepth < zReceiver) {\r\n            blockerDepthSum += shadowMapDepth;\r\n            numBlockers++;\r\n        }\r\n    }\r\n\r\n    if(numBlockers == 0)\r\n        return -1.0;\r\n\r\n    return blockerDepthSum / float(numBlockers);\r\n}\r\n\r\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\r\n    float sum = 0.0;\r\n    float depth;\r\n\t\t\t\t\t#pragma unroll_loop_start\r\n    for(int i = 0; i < 17; i++) {\r\n        depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * filterRadius));\r\n        if(zReceiver <= depth)\r\n            sum += 1.0;\r\n    }\r\n\t\t\t\t\t#pragma unroll_loop_end\r\n\t\t\t\t\t#pragma unroll_loop_start\r\n    for(int i = 0; i < 17; i++) {\r\n        depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[i].yx * filterRadius));\r\n        if(zReceiver <= depth)\r\n            sum += 1.0;\r\n    }\r\n\t\t\t\t\t#pragma unroll_loop_end\r\n    return sum / (2.0 * float(17));\r\n}\r\n\r\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\r\n    vec2 uv = coords.xy;\r\n    float zReceiver = coords.z; // Assumed to be eye-space z in this code\r\n\r\n    initPoissonSamples(uv);\r\n\t\t\t\t\t// STEP 1: blocker search\r\n    float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\r\n\r\n\t\t\t\t\t//There are no occluders so early out (this saves filtering)\r\n    if(avgBlockerDepth == -1.0)\r\n        return 1.0;\r\n\r\n\t\t\t\t\t// STEP 2: penumbra size\r\n    float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\r\n    float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\r\n\r\n\t\t\t\t\t// STEP 3: filtering\r\n\t\t\t\t\t//return avgBlockerDepth;\r\n    return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\r\n}",
        "pcss_get_shadow_glsl": "return PCSS( shadowMap, shadowCoord );"
    }
}
